<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-image/iron-image.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../iron-media-query/iron-media-query.html">
<link rel="import" href="../neon-animation/neon-animation.html">
<link rel="import" href="../neon-animation/neon-animations.html">

<!--
This element displays a grid of material design cards.
Each card could have an importance. Each row of this component has a `weightPerRow`.
This means that a row could have several cards. But the sum of the cards importances
will always be below the `weigthPerRow` property.

Example:

    <wid-cards-grid
      cards="[[cards]]"
      on-card-tap="_onCardTap"
      weightPerRow="7">
    </wid-cards-grid>

@group Wid
@element wid-cards-grid
@demo demo/index.html
-->
<dom-module id="wid-cards-grid">

  <style>

    :host {
      display: block;
    }

    #cards-container {
      display: none;
    }

    wid-card .caption {
      min-height: 64px;
    }

    wid-card iron-icon {
      width: 64px;
      height: 64px;
      padding: 10px;
    }

    wid-card iron-image {
      width: 100%;
      height: 100%;
    }

    wid-card .tile-content h4, wid-card .tile-content p {
      margin: 0;
      text-align: center;
    }

    wid-card [title] {
      color: var(--wid-cards-grid-title-color, black);
    }

    wid-card [category] {
      color: var(--wid-cards-grid-category-color, #C2C2C2);
    }

    :host > div {
      background-color: var(--wid-cards-grid-background-color, white);
    }

  </style>

  <template>

    <div id="cards-container">
      <content id="cards" select="[card]"></content>
    </div>

    <iron-media-query query="(max-width: 639px)" query-matches="{{_isMobile}}"></iron-media-query>

    <div class="layout vertical">

      <template is="dom-repeat" items="[[_gridLayout]]" as="row" index-as="i">

        <div class="layout horizontal flex-auto wrap">

          <template is="dom-repeat" items="[[row]]" as="card" index-as="j">

            <div id$="[[_computeInsertionId(i, j)]]"></div>

          </template>

        </div>

      </template>

    </div>

  </template>

</dom-module>

<script>
  Polymer({
    is: 'wid-cards-grid',

    behaviors: [
      Polymer.NeonSharedElementAnimatableBehavior
    ],

    properties: {
      /**
       * The current selected card.
       * @type {Object}
       */
      currentCard: {
        type: Object,
        notify: true
      },

      /**
       * Whether calling an animation on the `currentCard` when leaving this component.
       * @type {Boolean}
       */
      exitCardAnimatable: {
        type: Boolean,
        value: false
      },

      /**
       * The animation to call on the currentCard on exit.
       * @type {String}
       */
      cardAnimatableType: {
        type: String,
        value: 'fade-out'
      },

      /**
       * The cards to display in the grid.
       * @type {[Object]}
       */
      _cards: {
        type: Array,
        observer: '_cardsChanged'
      },

      /**
       * The private model of the grid.
       * @type {Object}
       */
      _gridLayout: {
        type: Object
      },

      /**
       * Each card has a score.
       * One row must have the sum of its card scores below this value.
       * @type {Number}
       */
      weightPerRow: {
        type: Number,
        value: 7
      },

      /**
       * Animation configuration. Cf. `neon-animation`
       * @type {AnimationConfig}
       */
      animationConfig: {
        type: Object,
        value: function() {
          return {
            'exit': [{
              name: 'ripple-animation',
              id: 'ripple',
              fromPage: this
            }, {
              name: 'hero-animation',
              id: 'hero',
              fromPage: this
            }]
          };
        }
      }
    },

    listeners: {
      'card-tap': '_onProjectTileTap',
      'dom-change': '_handleDomChange'
    },

    ready: function () {
      this.async(function() {
        this._cards = Polymer.dom(this.$.cards).getDistributedNodes();
      }, 1);
    },

    _computeInsertionId: function(i, j) {
      console.log('toInsert', i, j);
      return 'test'+ j;
    },

    _handleDomChange: function () {

      for (var i = 0; i < 4; i++){
        Polymer.dom(this.root).querySelector('#test' + i).appendChild(this._cards[i]);
      }

    },


    /**
     * This method place a card in a row that have enough space
     * to receive the card or in a new row.
     * This algorithm is greedy.
     * @param  {[Row]} rows The rows of the grid layout
     * @param  {Card} card A card to be palced.
     * @return {[Row]}      The new rows.
     */
    _putCardInRow: function (rows, card) {
      var cardInserted = false,
          i, ii,
          importance = ((card.importance) ? card.importance : 1); //a card has at least an importance of 1.

      for (i = 0, ii = rows.length ; i < ii; i++) {

        if (rows[i].remainingWeight >= importance) {
          rows[i].cards.push(card);
          rows[i].remainingWeight -= importance;
          cardInserted = true;
          break;
        }

      }
      if (!cardInserted) {
        rows[rows.length] = {
          cards: [card],
          remainingWeight: this.weightPerRow - importance
        };
        rows.length++;
      }

      return rows;
    },

    /**
     * When the `cards` property changes. This method is called.
     * Recreate the grid layout based on the cards scores.
     * @return {GridLayout} The grid layout
     */
    _cardsChanged: function () {

      var rows = {
            length: 0
          }, //temp map containing the gridLayout
          rowsArray = [], //definitive array containing the gridLayout
          card,
          i, ii, j, jj;

      //first we create the temporary map containing the layout
      for (i = 0, ii = this._cards.length; i < ii; i++) {

        card = this._cards[i];
        this._putCardInRow(rows, card);

      }

      //then we convert this map into an array
      for (j = 0, jj = rows.length; j < jj; j++) {
        rowsArray.push(rows[j].cards);
      }
      this._gridLayout = rowsArray;
      return this._gridLayout;

    },

    /**
     * This method compute the card CSS classes.
     * Basically, it adjust the flex class accroding to the card importance.
     * @param  {Number} importance Card importance
     * @param  {Boolean} isMobile Whether the user is on mobile
     * @return {String}            The CSS classes
     */
    _computeCardClasses: function(importance, isMobile) {
      var value = 'auto';
      if (importance && !isMobile) {
        value = importance;
      }
      return 'layout vertical flex-' + value;
    },

    /**
     * Update the exit animation.
     * This method is usefull to call a animation method on the selected card.
     * @param  {Card} card The card on which we call an animation.
     */
    _updateExitAnimation: function (card, useExitAnimation) {
      this.animationConfig.exit = [this.animationConfig.exit[0], this.animationConfig.exit[1]];

      if (useExitAnimation) {
        this.animationConfig.exit.concat({
          animatable: card,
          type: this.cardAnimatableType
        });
      }
    },

    /**
     * Called on click on a card.
     * @param  {CustomEvent} e The event.
     */
    _onProjectTileTap: function (e) {

      this.currentCard = e.target;
      this.sharedElements = {
        'hero': e.target,
        'ripple': e.target
      };

      this._updateExitAnimation(e.target, this.exitCardAnimatable);
    }
  });
</script>
